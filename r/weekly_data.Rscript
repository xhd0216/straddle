library('tseries')
library('optparse')

assert <- function(x) {stopifnot(isTRUE(x))}

wp <- function(df, cutoff='weeks') {
  dates <- row.names(df)
  weeks <- cut(as.Date(dates), cutoff)
  dw <- data.frame(df, Weeks=weeks)

  ret <- data.frame(matrix(ncol=4, nrow=0))
  colnames(ret) <- c('Open', 'High', 'Low', 'Close')
  for (w in unique(weeks)) {
    ss <- dw[dw$Weeks==w,]
    ret[w,] <- c(ss[1,]$Open, max(ss$High), min(ss$Low), ss[nrow(ss),]$Close)
  }
  return(ret)
}

wpc <- function(df, cutoff='weeks', quote='Close') {
  ret = wp(df, cutoff=cutoff)
  rn = row.names(ret)
  ret = ret[quote]
  row.names(ret) <- rn
  return(ret)
}

stock.return <- function(closes) {
  return(data.frame(diff(as.matrix(closes))) / closes[-nrow(closes),])
}

stock.vol <- function(closes, days_in_year=250) {
  ret <- stock.return(closes)
  vol <- sd(ret) * sqrt(days_in_year)
  return(vol)
}

stock.downloads <- function(tik, start, end) {
  dat <- get.hist.quote(instrument=tik, start=start)
  return(data.frame(dat))
}

stock.corr <- function(symbols, start='1993-01-01', end='2099-12-31', period='days', quote='Close', cache=TRUE) {
  # download data
  ns <- length(symbols)
  all_closes <- NULL
  for (n in 1:ns) {
    s <- symbols[n]
    da <- download(tik=s, start=start, cache=TRUE)
    da <- wpc(da, period, quote)
    colnames(da) <- c(s)
    if (n == 1) {
      all_closes = da
    }
    else {
      all_closes <- merge(all_closes, da, by=0)
      row.names(all_closes) <- all_closes$Row.names
      all_closes$Row.names <- NULL
    }
  }
  all_closes = get.between.dates(all_closes, start, end)
  close.returns <- stock.return(all_closes)
  return(corr(close.returns))
}

read.cache <- function(fn, start, end, allow_gap) {
  df <- read.csv(fn, row.names=1)
  das <- row.names(df)
  std <- as.Date(head(das, 1))
  edd <- as.Date(tail(das, 1))
  cat(paste0("loaded data\nstart=", std, " looking for=", start, "\nend=", edd, " looking for=", end, "\n"))
  assert(!(std - as.Date(start) > allow_gap || as.Date(end) - edd > allow_gap))
  return(df)
}

download <- function(tik='spy', start='2017-01-01', end=Sys.Date(), cache=TRUE, allow_gap=5) {
  fname <- paste0(tik, '_data.csv')
  is.done = FALSE
  cat("trying to load", tik, "from cache\n")
  if (cache) {
    tryCatch(
      {df <- read.cache(fname, start, end, allow_gap); is.done=TRUE;},
      #warning = function(w) {print(w)},
      #error = function(e) {print(e)},
      warning = function(w) {},
      error = function(e) {},
      finally = {})
  }
  if (!is.done) {
    dat <- get.hist.quote(instrument=tik, start=start)
    df <- data.frame(dat)
    write.csv(df, file=paste0(tik, '_data.csv'))
    print("get from web")
  }
  return(df)
}

get.between.dates <- function(data, start, end) {
  return(data[row.names(data) >= start & row.names(data) <= end, ])
}

corr <- function(df) {
  nc <- ncol(df)
  ret.matrix <- matrix(, nrow = nc, ncol = nc)

  for (i in 1:nc) {
    for (j in 1:nc) {
      ret.matrix[i, j] <- ret.matrix[j, i] <- cor(unlist(df[i]), unlist(df[j]))
    }
  }
  row.names(ret.matrix) <- colnames(df)
  colnames(ret.matrix) <- colnames(df)
  ret <- data.frame(ret.matrix)
  return(ret.matrix)
}

option_list <- list(
  make_option(c("-s", "--symbols"), type="character", help="symbols seperated by comma(,)", default="nugt,dust", ),
  make_option(c("--start"), type="character", help="start date YYYY-mm-dd", default="2018-01-01",)
)

opt <- parse_args(OptionParser(option_list=option_list))

syms <- strsplit(opt$symbols, ",")[[1]]

print(opt$start)
stock.corr(syms, start=opt$start, cache=TRUE)
